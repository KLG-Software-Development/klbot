# 一、更精准的指向——`SingleTypeModule<T>`的引入

## 1. 为什么需要`SingleTypeModule<T>`

首先需要意识到，不同种类的消息本质是不一样的。虽然纯文本消息`MessagePlain`有`Text`字段，代表消息的文本内容，但显然其他类型的消息例如图像消息`MessageImage`没有这一项——即使它也是`Message`类型。

然而，就目前而言，绝大部分模块都**只**处理纯文本消息。这意味着，如果我们想写一个读取消息文本内容的模块，必然要访问`Text`字段，而`Message`基类是没有这个字段的，所以处理之前必须先把它转换成`MessagePlain`类型——但注意，传入的消息完全有可能并不是`MessagePlain`类型，这又要求转换之前还要用`is`关键字判断它的类型，如果判断结果是对不上还要另外处理，blahblah...

显然这是一件并不困难但繁琐而且没用的事情。最傻逼的是，如果我们要写二十个这样的纯文本消息处理模块，在这二十个不同的模块里，**类似这样的傻缺代码我们需要复制粘贴二十次**，可是我们想做的仅仅只是用安全的方式取一个`Text`字段而已。

> 能不能把取这个字段的操作包装成函数来避免复制粘贴呢？

这当然是可以的。但即使这样，对每个要取的特殊字段，仍然不可避免要定义一个类似的函数，这堆函数除了返回类型和访问字段不同，其他逻辑仍然完全相同。因此，用这种方法只能避免访问**同一个字段**时无意义的复制粘贴，却无法避免访问**多个字段**时的 仍然毫无意义的、对函数的复制粘贴（和轻微改动）。并且由于函数签名完全不同，**在不使用反射的情况下**，原则上不可能把这一堆复制人函数的功能统一包装成一个大函数。

至于反射......**我只是赋个值，你还想让我上反射？？？**

> 那么能不能直接把`Module`定义里处理的类型从`Message`改成`MessagePlain`呢？

这个问题的答案是，逻辑上可以改，但是从向后兼容的角度考虑不能改。因为要考虑到未来处理图像消息乃至其他种类消息的可能性，我们不能不负责任地直接假设所有`Module`处理的消息类型全部是`MessagePlain`。

> 给`Module`类加个泛型`Module<T>`，且其中`T`属于`Message`类型，然后传入消息类型改为`T`，这样总可以了吧？比如处理文本的模块，就可以直接定义为继承`Module<MessagePlain>`，这样传入参数就会自动变成`MessagePlain`了。如果以后有处理语音的模块，定义为继承`Module<MessageVoice>`即可。似乎非常完美，既避免了类型判断，又保证了向后兼容。

实际上v0.4乃至更早版本的`klbotlib`确实就是这样实现的。但是这样过早地引入泛型，会导致模块的基类各不相同。比如上面说的处理文本的模块和处理语音的模块，二者会分别属于`Module<MessagePlain>`和`Module<MessageVoice>`两个事实上不同的类型。这会导致KLBot的模块链条只能定义为对象数组，并且引发一系列连锁反应，进一步在其他地方导致各种不严谨不优雅的设计...总而言之，这种解决方案虽然可行，但是和模块轻量化的目标有**根本矛盾**——而后者恰恰是v0.5版本的更新目标。

因此，在v0.5版本更新中，新的解决方案出现了——`SingleTypeModule<T>`，其中T是Message类。这个类继承了`Module`基类，但加入了泛型。

实际上，这个解决方案和上面的最后一种方案在本质上非常相近，唯一区别只是早期方案直接在`Module`类上动手脚，而v0.5的方案则优先保持`Module`类的统一性，先用一个类继承了`Module`，然后才在这个类身上，而非`Module`类上做手脚。这小小的跳板不但比早期方案更加符合逻辑（直接在`Module`上引入泛型实际上是在假设同一个模块只能处理同一种消息，但这明显是不严谨的），还保证了所有模块最后仍能约化到`Module`这一个统一的基类上，避免了后续一切难看的连锁反应。这就是`SingleTypeModule<T>`类。

`SingleTypeModule<T>`把上面所说的所有类型判断的废话包装在类中，从而避免了那些无意义却又不可避免的复制粘贴。

<br>

## 2. `SingleTypeModule<T>`的成员定义和详解

**如果你的模块只处理同一种类型的消息，除非你是受虐狂或者Ctrl+C/Ctrl+V爱好者，请继承`SingleTypeModule<T>`而非`Module`类**，前者可以帮你节约很多时间。其中，`T`为你的模块想要处理的消息类型，例如``MessagePlain``。

```CSharp
public abstract class SingleTypeModule<T> : Module where T : Message
{
    // 过滤器(T -> bool). 模块通过这个函数判断是否要处理某一条消息. 
    // 注意参数类型变成了T。这使得我们可以不用类型判断也能快乐地访问T中的字段
    public abstract bool Filter(T msg);
    // 处理器(T -> string). 模块通过这个函数处理所有(通过了过滤器的)消息. 
    // 注意参数类型变成了T。效果同上
    public abstract string Processor(T msg);
    //来自原版Module的过滤器和处理器。类型判断的废话都包装在这两个函数里面
    public sealed override bool Filter(Message msg);
    public sealed override string Processor(Message msg);
    //构造函数罢了
    public SingleTypeModule(KLBot host_bot) : base(host_bot) { }
}
```
